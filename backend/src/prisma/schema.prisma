generator client {
  provider = "prisma-client-js"
  output   = "../generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ENUMS
enum SchoolRole {
  ADMIN
  TEACHER
  STUDENT
  PARENT
}

enum GlobalRole {
  SUPER_ADMIN
  USER
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum AttendanceStatus {
  PRESENT
  ABSENT
  LATE
  EXCUSED
}

/**
 * * MODELS **
 */

model User {
  id         String      @id @default(cuid())
  email      String      @unique
  password   String
  globalRole GlobalRole?

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  deletedAt     DateTime?
  emailVerified DateTime?

  profile     Profile?
  memberships SchoolUser[]
  sessions    Session[]
  Account     Account[]

  @@index([email])
}

model Profile {
  id String @id @default(cuid())

  firstname String
  lastname  String
  phone     String?
  photo     String?
  gender    Gender?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique

  ParentStudent ParentStudent[]
  Student       Student[] // si un profil peut représenter plusieurs enregistrements d'élève (optionnel)
}

model School {
  id        String    @id @default(cuid())
  name      String
  slug      String    @unique
  address   String
  code      String?   @unique
  planId    String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  classes       Class[]
  students      Student[]
  memberships   SchoolUser[]
  subscriptions Subscription[]
  Subject       Subject[]
}

/**
 * pivot User <-> School
 */
model SchoolUser {
  id String @id @default(cuid())

  school   School @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  schoolId String

  user   User   @relation(fields: [userId], references: [id])
  userId String

  role      SchoolRole
  isOwner   Boolean    @default(false)
  createdAt DateTime   @default(now())

  subject      Subject[] // matières dont il est responsable (optionnel)
  ClassTeacher ClassTeacher[] // pivot prof <-> classe (s'il enseigne plusieurs classes)
  Class        Class[] // s'il est chef de classe (teacherId sur Class)

  @@unique([schoolId, userId])
  @@index([schoolId])
  @@index([userId])
  @@index([role])
}

/**
 * Subject: utilise pivot ClassSubjects (explicit)
 */
model Subject {
  id        String      @id @default(cuid())
  name      String
  code      String?
  school    School      @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  schoolId  String
  teacher   SchoolUser? @relation(fields: [teacherId], references: [id])
  teacherId String?

  // pivot explicit many-to-many
  ClassSubjects ClassSubjects[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Exam      Exam[]

  @@unique([code, schoolId])
  @@index([schoolId])
}

/**
 * Pivot explicit pour Class <-> Subject
 */
model ClassSubjects {
  id        String  @id @default(cuid())
  class     Class   @relation(fields: [classId], references: [id], onDelete: Cascade)
  classId   String
  subject   Subject @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  subjectId String

  @@unique([classId, subjectId])
  @@index([classId])
  @@index([subjectId])
}

model Exam {
  id        String   @id @default(cuid())
  title     String
  startDate DateTime
  endDate   DateTime
  class     Class    @relation(fields: [classId], references: [id])
  classId   String
  subject   Subject  @relation(fields: [subjectId], references: [id])
  subjectId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Result    Result[]

  @@index([classId])
  @@index([subjectId])
}

model Result {
  id        String   @id @default(cuid())
  student   Student  @relation(fields: [studentId], references: [id])
  studentId String
  exam      Exam     @relation(fields: [examId], references: [id])
  examId    String
  score     Float
  createdAt DateTime @default(now())

  @@unique([studentId, examId])
}

model Class {
  id        String   @id @default(cuid())
  name      String
  level     String
  section   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  school   School @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  schoolId String

  // chef de classe (optionnel) - SchoolUser relation
  teacher   SchoolUser? @relation(fields: [teacherId], references: [id])
  teacherId String?

  students Student[]
  exam     Exam[]

  // pivot explicit many-to-many
  classSubjects ClassSubjects[]
  ClassTeacher  ClassTeacher[]

  @@index([schoolId])
}

/**
 * Pivot Prof <-> Classe (nouveau)
 */
model ClassTeacher {
  id        String     @id @default(cuid())
  class     Class      @relation(fields: [classId], references: [id], onDelete: Cascade)
  classId   String
  teacher   SchoolUser @relation(fields: [teacherId], references: [id], onDelete: Cascade)
  teacherId String

  createdAt DateTime @default(now())

  @@unique([classId, teacherId])
  @@index([classId])
  @@index([teacherId])
}

/**
 * Etudiant
 */
model Student {
  id             String   @id @default(cuid())
  profile        Profile  @relation(fields: [profileId], references: [id])
  profileId      String
  matricule      String
  enrollmentYear String
  birthDate      DateTime

  school   School @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  schoolId String

  // classId optionnel (un élève peut ne pas être encore affecté)
  classId     String?
  schoolClass Class?  @relation(fields: [classId], references: [id])

  attendances Attendance[]
  Result      Result[]

  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  deletedAt     DateTime?
  ParentStudent ParentStudent[]

  @@unique([matricule, schoolId])
  @@index([schoolId])
}

/**
 * Parent - Student pivot
 */
model ParentStudent {
  id              String   @id @default(cuid())
  parentProfile   Profile  @relation(fields: [parentProfileId], references: [id])
  parentProfileId String
  student         Student  @relation(fields: [studentId], references: [id])
  studentId       String
  relationType    String?
  createdAt       DateTime @default(now())

  @@unique([parentProfileId, studentId])
}

/**
 * Invite
 */
model Invite {
  id        String     @id @default(cuid())
  email     String
  schoolId  String
  studentId String?
  token     String     @unique
  relation  String?
  createdAt DateTime   @default(now())
  expiresAt DateTime
  used      Boolean    @default(false)
  role      SchoolRole

  @@index([schoolId])
  @@index([studentId])
}

/**
 * Attendance
 */
model Attendance {
  id        String           @id @default(cuid())
  student   Student          @relation(fields: [studentId], references: [id])
  studentId String
  date      DateTime
  status    AttendanceStatus

  createdAt DateTime @default(now())

  @@unique([studentId, date])
  @@index([studentId, date])
}

/**
 * Billing
 */
model Plan {
  id           String         @id @default(cuid())
  name         String
  stripeId     String?
  priceCents   Int
  features     String?
  createdAt    DateTime       @default(now())
  subscription Subscription[]
}

model Subscription {
  id          String    @id @default(cuid())
  school      School    @relation(fields: [schoolId], references: [id])
  schoolId    String
  plan        Plan      @relation(fields: [planId], references: [id])
  planId      String
  stripeSubId String?
  status      String
  startedAt   DateTime  @default(now())
  endedAt     DateTime?
  createdAt   DateTime  @default(now())

  @@index([schoolId])
}

/**
 * * NextAuth required models **
 */
model Account {
  id                String  @id @default(cuid())
  user              User    @relation(fields: [userId], references: [id])
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime
  createdAt  DateTime @default(now())

  @@unique([identifier, token])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  user         User     @relation(fields: [userId], references: [id])
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())

  @@index([userId])
}
